<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Trust Region Reflective?</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>


<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<h1>Trust Region Reflective?</h1>

<h2>To improve speed !</h2>

<h3>Using Cpp</h3>

<ul>
<li><a href="https://github.com/hadley/devtools/wiki/Rcpp">https://github.com/hadley/devtools/wiki/Rcpp</a></li>
<li><a href="http://www.cplusplus.com/articles/1ywTURfi/">http://www.cplusplus.com/articles/1ywTURfi/</a></li>
<li><a href="http://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B">http://en.wikipedia.org/wiki/Compatibility_of_C_and_C%2B%2B</a></li>
</ul>

<h3>Better finite differece</h3>

<p><u>some text</u></p>

<ul>
<li>Quoted from <a href="https://stat.ethz.ch/pipermail/r-help/2008-March/158228.html">https://stat.ethz.ch/pipermail/r-help/2008-March/158228.html</a></li>
</ul>

<p>If &#39;myfunc&#39; is a vector function and can be vectorized in R, then it 
is even faster to use the following:</p>

<pre><code class="r">

grad.vec &lt;- function(x, fn, ..., eps = sqrt(.Machine$double.neg.eps)) {
    x1 &lt;- x + eps * pmax(abs(x), 1)
    x2 &lt;- x - eps * pmax(abs(x), 1)
    (fn(x1, ...) - fn(x2, ...))/(x1 - x2)
}

grad.1 &lt;- function(x, fn) {
    x &lt;- sort(x)
    x.e &lt;- head(embed(x, 2), -1)
    y.e &lt;- embed(fn(x), 3)
    hh &lt;- abs(diff(x.e[1, ]))
    apply(y.e, 1, function(z) (z[1] - z[3])/(2 * hh))
}

myfunc.1 &lt;- function(x) {
    (exp(x) - x)/10
}

p0 &lt;- rexp(1000)
system.time(for (i in 1:500) out1 &lt;- grad.1(p0, myfunc.1))
</code></pre>

<pre><code>##    user  system elapsed 
##    2.36    0.00    2.36
</code></pre>

<pre><code class="r">system.time(for (i in 1:500) out2 &lt;- grad.vec(p0, myfunc.1))
</code></pre>

<pre><code>##    user  system elapsed 
##    0.12    0.00    0.13
</code></pre>

<pre><code class="r">
</code></pre>

<ul>
<li><a href="http://www.mathworks.com/matlabcentral/answers/7898">http://www.mathworks.com/matlabcentral/answers/7898</a></li>
</ul>

<h2>New Implememtaion and Test Results!</h2>

<pre><code class="r">library(KineticEval)
setwd(&quot;C:/Projects2013/KinEvalGit/&quot;)
data(schaefer07_complex_case)
model &lt;- mkinmod.full(parent = list(type = &quot;SFO&quot;, to = c(&quot;A1&quot;, &quot;B1&quot;, &quot;C1&quot;), 
    sink = FALSE), A1 = list(type = &quot;SFO&quot;, to = &quot;A2&quot;), B1 = list(type = &quot;SFO&quot;), 
    C1 = list(type = &quot;SFO&quot;), A2 = list(type = &quot;SFO&quot;), data = schaefer07_complex_case)

Fit2 &lt;- NULL
alglist &lt;- c(&quot;L-BFGS-B&quot;, &quot;Marq&quot;, &quot;Port&quot;, &quot;spg&quot;, &quot;solnp&quot;, &quot;LM&quot;)
for (i in 1:6) {
    Fit2[[i]] &lt;- mkinfit.full(model, plot = FALSE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
## Save Fit2
names(Fit2) &lt;- alglist
save(Fit2, file = &quot;Fit_Schaefer.rda&quot;)


(lapply(Fit2, function(x) x$par))
unlist(lapply(Fit2, function(x) x$ssr))
##########################

##########################
load(&quot;ex1.rda&quot;)
load(&quot;ex1_a.rda&quot;)
# data(ex1_a)
alglist &lt;- c(&quot;L-BFGS-B&quot;, &quot;Marq&quot;, &quot;Port&quot;, &quot;spg&quot;, &quot;solnp&quot;, &quot;LM&quot;)
Fit &lt;- NULL
for (i in 1:6) {
    Fit[[i]] &lt;- mkinfit.full(ex1, plot = TRUE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
names(Fit) &lt;- alglist
(lapply(Fit, function(x) x$par))
kinplot(Fit[[6]])
unlist(lapply(Fit, function(x) x$ssr))
Fit_a &lt;- NULL
for (i in 1:6) {
    Fit_a[[i]] &lt;- mkinfit.full(ex1_a, plot = TRUE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
unlist(lapply(Fit_a, function(x) x$ssr))

## Test on data andrew:
data(andrew)
mkinmodini &lt;- mkinmod.full(Parent = list(type = &quot;SFO&quot;, to = &quot;Metab&quot;), Metab = list(type = &quot;SFO&quot;, 
    M0 = list(ini = 0, fixed = 0, lower = 0, upper = Inf)), data = andrew)
for (i in 1:6) {
    Fit[[i]] &lt;- mkinfit.full(mkinmodini, plot = FALSE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
names(Fit) &lt;- alglist
(lapply(Fit, function(x) x$par))
unlist(lapply(Fit, function(x) x$ssr))

#####################
load(&quot;ex2.rda&quot;)
Fit2 &lt;- NULL
alglist &lt;- c(&quot;L-BFGS-B&quot;, &quot;Marq&quot;, &quot;Port&quot;, &quot;spg&quot;, &quot;solnp&quot;, &quot;LM&quot;)
for (i in 1:5) {
    Fit2[[i]] &lt;- mkinfit.full(ex2, plot = FALSE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}

</code></pre>

<h2>Trust Region Theory and Implementation</h2>

<h3>Advantages:</h3>

<p>The primary advantage of trust region methods is stability. </p>

<ul>
<li><p>requires gradient and Hessian of the objective function</p></li>
<li><p>is guaranteed to converge to a point satisfying the first and second order necessary conditions for a local optimum (gradient zero and Hessian positive semidefinite for minimization or negative semidefinite for maximization). nlm and optim come with no guarantees and often perform badly on difficult problems. </p></li>
<li><p>handles restricted domains so long as the solution is in the interior of the domain. </p></li>
<li><p>does not do global optimization, but neither does anything else in R.</p></li>
</ul>

<h3>General Ideas:</h3>

<p>Suppose \( f : R^n \to R \) is a function we wish to minimize. The basic idea of trust region is to approximate \( f \) with a simpler function \( q \) (a quadradtic model) at the neighborhood \( N \)(trust region) aound point \( x \). </p>

<p>\[ q_k(p)=f(x_k)+\nabla{f(x_k)}^Tp+\frac{1}{2}p^T\nabla^2{f(x_k})p \].</p>

<p>A trial step is caclculated by minimizing \( q(s) \). This is the trust region supproblem,</p>

<p>\[ \min \{q(s), s \in N\} \]</p>

<p>where \( s\in N \) is defined by \( \|D_is\|\leq\Delta \), \( \Delta >0 \) is the radius of the trusted region. So the subproblems is to solve</p>

<p>\[ \min q_k(s) \text{ subject to } \|Ds\|\leq\Delta \],</p>

<p>Suppose \( p_k \) is a solution to the trust region subproblem. The adjustment of \( \Delta_k \) is done as follows
\[ 
   \rho_k = \frac{f(x_k) - f(x_k + p_k)}{q_k(0) - q_k(p_k)}
 \]
which is the actual decrease in the objective function \( f \) in the step
compared to the predicted decrease using \( q_k \).  If \( \rho_k \) is small
or negative, then \( q_k \) is a bad model at \( x_k + p_k \) so the trial step should not be used and the trust region radius should be adjusted.</p>

<h3>Trust Region Subproblem(TRS)</h3>

<p>A vector \( p^* \) is a global solution to the trust region subproblem if and only if
\[ 

   \lVert p^* \rVert \le \Delta

 \]
and there exists a scalar \( \lambda \ge 0 \) such that
\[ 
\begin{gather}
   (B + \lambda I) p^* = - g
   \label{eq:derivative}
   \\
   \lambda = 0 \quad \text{or} \quad \lVert p^* \rVert = \Delta
  
   \\
   B + \lambda I \ \text{is positive semidefinite}
   
\end{gather}
 \]
where \( B_k = \nabla^2 f(x_k) \). </p>

<ul>
<li><p>Case \( \lambda=0 \): If \( B \) is positive definite and
\( p^* = - B^{-1} g \) satisfies \( \|p^*\|\le \Delta \), then that is the solution.</p></li>
<li><p>Case \( \|p^*\| = \Delta \), Define
\[ 
\begin{equation} \label{eq:plambda}
   p(\lambda)
   =
   - (B + \lambda I)^{-1} g
   =
   - \sum_{j = 1}^{n} \frac{q_j^T g}{\lambda_j + \lambda} q_j
\end{equation}
 \]
where \( \lambda_j \) are the eigenvalues of \( B \) and \( q_j \) are the corresponding orthonormal eigenvectors (this is valid only when \( \lambda \neq - \lambda_j \) for all \( j \)). Then
\[ 
   \lVert p(\lambda) \rVert^2
   =
   \sum_{j = 1}^{n} \left( \frac{q_j^T g}{\lambda_j + \lambda} \right)^2
 \]
The analysis again splits into several cases.</p></li>
</ul>

<ol>
<li>Let \( \lambda_{\text{min}} \) denote the minimum eigenvalue of \( B \). If
\[  (q_j^T g) \neq 0, \qquad \text{for some $j$ such that
   $\lambda_j = \lambda_{\text{min}}$}
    \]
then \( p(\lambda) \) is a continuous, strictly decreasing function on the open interval \( (- \lambda_{\text{min}}, \infty) \) and goes to \( \infty \)
as \( \lambda \to - \lambda_{\text{min}} \) and to zero as \( \lambda \to \infty \). Thus a \( \lambda^* \) such that \( \lVert p(\lambda^*) \rVert^2 = \Delta^2 \) exists and is unique, and \( p(\lambda^*) \) is the solution to the trust region subproblem.</li>
<li>In the other case, \( p(\lambda) \) is continuous at \( \lambda = \lambda_{\text{min}} \) and now defines a continuous strictly decreasing function on
the closed interval \( [- \lambda_{\text{min}}, \infty) \), and \( \lambda \)
must be in this interval in order for \( B+\lambda I \) being positive definite.</li>
</ol>

<p>If \( \lVert p(- \lambda_{\text{min}}) \rVert^2 > \Delta^2 \), then there is still a unique \( \lambda^* \) in \( (- \lambda_{\text{min}}, \infty) \)
such that \( \lVert p(\lambda^*) \rVert^2 = \Delta^2 \), this \( p(\lambda^*) \) is the solution to the TRS. Otherwise, we must have \( \lambda = - \lambda_{\text{min}} \).Then \( B + \lambda I \) is singular, and the \( p(\lambda) \) defined above can no longer be used. Now solutions of \( (B+\lambda_i)p=-g \) 
are non-unique, and we have
\[ 
\begin{equation} 
   p_{\text{hard}}(\tau)
   =
   - \sum_{\substack{j = 1 \\ \lambda_j \neq \lambda_{\text{min}}}}^n
   \frac{q_j^T g}{\lambda_j - \lambda_{\text{min}}} q_j
   +
   \sum_{\substack{j = 1 \\ \lambda_j = \lambda_{\text{min}}}}^n
   \tau_j q_j
\end{equation}
 \]
is a solution of \( (B+\lambda_i)p=-g \) for every vector \( \tau \).
Since the first sum on the right hand side has
norm less than \( \Delta \) by the falsity of \( \lVert p(- \lambda_{\text{min}}) \rVert^2 > \Delta^2 \), we can choose \( \tau \) to make \( \lVert p_{\text{hard}}(\tau) \rVert = \Delta \). The nonuniqueness is not an issue, because (at least as far as the subproblem is concerned) one solution is just as good as another.</p>

<ul>
<li>Steihuang(above procedure)</li>
<li>Dogleg, STIR</li>
</ul>

<h3>Practical Newton Methods - Trust-Region Newton Methods</h3>

<ul>
<li>Newton-dogleg</li>
<li>Newton-2D subspace </li>
<li>Newton- Nearly Exact Solution</li>
<li>Trust Region Newton-(P)CG</li>
</ul>

<h3>Finite Difference ?</h3>

<ul>
<li><p>numerical gradients calculated by finite-difference approximation.</p></li>
<li><p><a href="http://terminus.sdsu.edu/SDSU/Math693a_f2012/?r=sched">http://terminus.sdsu.edu/SDSU/Math693a_f2012/?r=sched</a>   (Best reference lecture notes for me on numerical optimization)</p></li>
</ul>

<h3>Tricks in Matlab <code>lsqnonlin</code> implementation</h3>

<p>The TRR in matlab involves the following steps:</p>

<ol>
<li><p>Consider the trust region subproblem of finding trial step \( s_i \) between the \( i \)-th point \( x_i \) and the next point \( x_{i+1} \) that minimizes \( q_i(s) \). Formulate the 2-dimentional subspace \( V \) with 2 spanning vectors \( v_1 \) and \( v_2 \). One vector is in the direction of the gradient \( x_i \) and the other either in the approximate Gauss-Newton direction, i.e, a solution to \( H\cdot v_2=-g \) or a direction of negative curvature(\( v_2^T\cdot H \cdot s_2 < 0 \)).</p>

<p>For nonlinear least squares, suppose \( f=\sum_i f_i(x)^2 \) , let \( F=(f_1(x), ..., f_n(x)) \), then \( f=\|F\| \). The structure of nonlinear least square problems can be exploited to enhance efficiency. In particular, the approximate Gauss-Newton direction, i.e. a solution \( s \) to \( \min\|Js+F\|^2_2 \) is used to help define the 2-dimentional subspace \( V \). In each iteration, the method of preconditioned conjugate gradients(PCG) is used to approximately solve the normal equation, i.e. \( J^TJs=-J^TF \), although the normal equations are not explicitly fomed</p></li>
<li><p>Solve for the trial step \( s_i \) of the 2-dimentional subproblem, i.e, solve the following equation: 
\[ \min\{ \frac{1}{2}s^THs+s^Tg, \text{ subject to } \|D_is\|\leq\Delta_i\}  \]
where \( g \) is the gradient and \( H \) is the Hessian matrix at the current point.</p></li>
<li><p>If for a predefined constant \( 0 < \tau < 1 \), \( f(x_i+s) < f(x_i) \), then \( x_{i+1} \) becomes the current point, otherwise \( x_{i+1}=x_i \).</p></li>
<li><p>Update \( \Delta_i \). In particular, it is decreased if the trial step is not accepted.</p></li>
</ol>

<p>These 4 steps are repeated until convergence, i.e., if \( \nabla f(s_i) \) is below a chose tolerance level, the algorithm ends.</p>

<p>PCG uses a preconditioner matrix \( P \) that makes the equation \( Ax=b \) easier to solve by turning it into \( P^{-1}(Ax-b)=0 \)</p>

<pre><code>lsqnonlin -&gt; snls -&gt; sfdnls, trdog
</code></pre>

<h3>Algorithm STIR(subspace trust region interior reflective)</h3>

<p>Let \( 0<\mu<\eta<1, 0<\Lambda_l<\Lambda_u \), and \( \gamma_1<1<\gamma_2 \) be given. Let \( x_0\in\text{int}(F) \), \( \Delta_0<\Lambda_u \).</p>

<p>For \( k=0,1,... \)</p>

<ol>
<li><p>Compute \( f_k, g_k, D_k, H_k \), and \( C_k \); define the quardratic model
\[ 
\psi_k(s)=g_k^Ts+\frac{1}{2}s^T(H_k+C_k)s.
 \]</p></li>
<li><p>Compute a step \( s_k \), with \( s_k+x_k\in\text{int}(F) \), based on the subspace problem
\[ 
\min \psi_k(s) \text{ subject to } \|D_ks\|_2\leq\Delta_k, s\in S_k
 \]
where the subspace \( S_k \) is set up as below.</p></li>
<li><p>Compute 
\[ 
\rho_k=\frac{f(x_k+s_k)-f(x_k)+\frac{1}{2}s_k^TC_ks_k}{\psi_k(s_k)}
 \]</p></li>
<li><p>If \( \rho_k>u \) then set \( x_{k+1}=x_k+s_k \). Otherwise set \( x_{k+1}=x_k \).</p></li>
<li><p>Update \( \Delta_k \) as specified below.</p></li>
</ol>

<p><strong>Determin Subspace \( S_k \)</strong></p>

<p><strong>Updating Trust Region Size \( \Delta_k \)</strong> </p>

<ol>
<li>If \( \rho_k<\mu \) then set \( \Delta_{k+1}\in (0, \gamma_1\Delta_k] \).</li>
<li>If \( \rho_k\in(\mu,\eta) \) then set \( \Delta_{k+1}\in [\gamma_1\Delta_k\, \Delta_k] \).</li>
<li>If \( \rho_k\geq \eta \) then 

<ul>
<li>if \( \Delta_k>\Lambda_l \) then set \( \Delta_{k+1}\in \) either \( (\gamma_1\Delta_k\, \Delta_k] \) or \( [\Delta_k, \gamma_2\Delta_k] \).</li>
<li>otherwise, set \( \Delta_{k+1}\in[\Delta_k, \min(\gamma_2\Delta_k,\Lambda_u)] \)</li>
</ul></li>
</ol>

<h3>Some other&#39;s opinions</h3>

<p>Lsqnonlin is a modern implementation of the Levenberg-Marquardt(LM) method, which is the most popular algorithm for nonlinear least squares.</p>

<p>Global convergence from arbitrary starting points is promoted via a trust region technique: at each iteration a quadratic surrogate model of the actual problem is constructed, and solved subject to a trust region - a ball around the current iterate, where the surrogate model is likely to be a good approximation of the true problem function.</p>

<p>There&#39;s also a more classical line-search implementation of LM in lsqnonlin - to run it you have to change an option (see the link below for details).</p>

<p>If the problem has bounds on the variables (say, all the parameters between zero and one), lsqnonlin uses an interior point method, which a modern approach to handling inequality constraints.</p>

<p>More general constraints other than bounds are handled by the solver fmincon.</p>

<p>If the problem is large scale (this doesn&#39;t happen very often in practice for nonlinear least squares), lsqnonlin has the option to use/estimate sparse Jacobians, or work with a Jacobian-times vector function instead of the Jacobian itself.</p>

<h3>Lectures and Notes</h3>

<ul>
<li><a href="http://www.mcs.anl.gov/%7Eanitescu/CLASSES/2012/LECTURES/S310-2012-lect5.pdf">http://www.mcs.anl.gov/~anitescu/CLASSES/2012/LECTURES/S310-2012-lect5.pdf</a></li>
<li><a href="http://www.cs.umd.edu/users/oleary/a607/2008/index.html">http://www.cs.umd.edu/users/oleary/a607/2008/index.html</a></li>
</ul>

<h3>Other&#39;s implementation</h3>

<ul>
<li><a href="https://bitbucket.org/carandraug/octave/src/13d1e9bfa362/scripts/optimization/lsqnonneg.m?at=default">https://bitbucket.org/carandraug/octave/src/13d1e9bfa362/scripts/optimization/lsqnonneg.m?at=default</a></li>
<li><a href="http://homepages.rpi.edu/%7Emitchj/pack.html">http://homepages.rpi.edu/~mitchj/pack.html</a></li>
<li><p><a href="https://github.com/dkogan/libdogleg">https://github.com/dkogan/libdogleg</a></p></li>
<li><p><a href="http://mind.cog.jhu.edu/courses/680/octave/Installers/Octave/Octave.OSX10.6/Applications/MATLAB_R2009b.app/toolbox/optim/optim/">http://mind.cog.jhu.edu/courses/680/octave/Installers/Octave/Octave.OSX10.6/Applications/MATLAB_R2009b.app/toolbox/optim/optim/</a></p></li>
</ul>

<hr/>

<h2>Differential Equation and Jacobian!!</h2>

<ul>
<li><a href="http://leto.net/x/2008/11/5-minute-math-lesson-what-is-a.html">http://leto.net/x/2008/11/5-minute-math-lesson-what-is-a.html</a></li>
</ul>

<hr/>

<h2>Using Sparse Matrice in R</h2>

<pre><code class="r">library(&quot;Matrix&quot;)

m1 &lt;- matrix(0, nrow = 1000, ncol = 1000)
m2 &lt;- Matrix(0, nrow = 1000, ncol = 1000, sparse = TRUE)

object.size(m1)
# 8000200 bytes
object.size(m2)
# 5632 bytes

m1[500, 500] &lt;- 1
m2[500, 500] &lt;- 1

object.size(m1)
# 8000200 bytes
object.size(m2)
# 5648 bytes

</code></pre>

<p>The full matrix representation does not change in size because all of the zeros are being represented explicitly, while the sparse matrix is conserving that space by representing only the non-zero entries. With a simple subtraction, we find that adding one additional non-zero entry increases the storage requirement by 16 bytes. We can conclude that setting all of the entries to non-zero values would require 5632 + 16 * 1000 * 1000 bytes, which is 16,005,632 bytes or almost exactly twice the amount of storage required to use the full representation implemented by the matrix class.</p>

<p>Of course, the take away lesson is that sparse matrices are very efficient if your data is sparse and mildly wasteful if your data is not sparse.</p>

<p>Beyond simple initialization and assignment operations, we can perform quite a few other operations on objects of class Matrix, including vector multiplication, matrix addition and subtraction and transposition. In addition you can do binding operations using objects of class Matrix with the cBind and rBind functions.</p>

<p>An alternative to the Matrix package is the slam package by Kurt Hornik and others. The sparse matrices generated using this package can be noticeably smaller than those generated by the Matrix package in some cases.</p>

<ul>
<li><a href="http://www.johnmyleswhite.com/notebook/2011/10/31/using-sparse-matrices-in-r/">http://www.johnmyleswhite.com/notebook/2011/10/31/using-sparse-matrices-in-r/</a></li>
</ul>

<hr/>

<h2>Least Square Special</h2>

<p>Chain rule can be applied to reduce amount of computation.</p>

<p>The derivatives are calculated numerically using Richardson improvement
The the first order derivative with respect to \( x_i \) is</p>

<p>\[ f'_{i}(x) = (f(x_{1},.,x_{i}+d,.,x_{n}) - f(x_{1},.,x_{i}-d,.,x_{n}))/(2*d) \]</p>

<p>The second order derivative with respect to \( x_i \) is</p>

<p>\[ f''_{i}(x) = (f(x_{1},.,x_{i}+d,.,x_{n}) - 2 *f(x_{1},.,x_{n}) + f(x_{1},.,x_{i}-d,.,x_{n}))/(d^2) \]</p>

<p>The second order derivative with respect to \( x_i, x_j \) is</p>

<p>\[ f''_{i,j}(x) = (f(x_{1},.,x_{i}+d,.,x_{j}+d,.,x_{n}) - 2 *f(x_{1},.,x_{n}) +

f(x_{1},.,x_{i}-d,.,x_{j}-d,.,x_{n}))/(2*d^2) - (f''_{i}(x) + f''_{j}(x))/2 \]</p>

<ul>
<li><a href="http://neos-guide.org/content/nonlinear-least-squares">http://neos-guide.org/content/nonlinear-least-squares</a></li>
<li><a href="http://support.sas.com/documentation/cdl/en/statug/63962/HTML/default/viewer.htm#statug_nlin_sect020.htm">http://support.sas.com/documentation/cdl/en/statug/63962/HTML/default/viewer.htm#statug_nlin_sect020.htm</a></li>
</ul>

<pre><code class="r">fm1 &lt;- gnls(weight ~ SSlogis(Time, Asym, xmid, scal), Soybean, weights = varPower())
summary(fm1)
</code></pre>

<h3>using nls instead of optim directly.</h3>

<p>The <code>nls</code> function works normally like the following:</p>

<pre><code> x &lt;- 1:10
 y &lt;- 2*x + 3                            # perfect fit
 yeps &lt;- y + rnorm(length(y), sd = 0.01) # added noise
 nls(yeps ~ a + b*x, start = list(a = 0.12345, b = 0.54321))#
</code></pre>

<p>Because the model I use have a lot of parameters or I don&#39;t know beforehand what will be included in the parameter list, I want something like following</p>

<pre><code>tmp &lt;- function(x,p) { p[&quot;a&quot;]+p[&quot;b&quot;]*x }
p0 &lt;- c(a = 0.12345, b = 0.54321)
nls(yeps ~ tmp(x,p), start = list(p=p0))
</code></pre>

<pre><code class="r">tmp &lt;- function(x, coef) {
    a &lt;- coef[1]
    b &lt;- coef[2]
    a + b * x
}

x &lt;- 1:10
y &lt;- 2 * x + 3  # perfect fit
yeps &lt;- y + rnorm(length(y), sd = 0.01)  # added noise
nls(yeps ~ a + b * x, start = list(a = 0.12345, b = 0.54321))  #
</code></pre>

<pre><code>## Nonlinear regression model
##   model:  yeps ~ a + b * x 
##    data:  parent.frame() 
## a b 
## 3 2 
##  residual sum-of-squares: 0.00124
## 
## Number of iterations to convergence: 2 
## Achieved convergence tolerance: 5.06e-09
</code></pre>

<pre><code class="r">nls(yeps ~ tmp(x, coef), start = list(coef = c(0.12345, 0.54321)))
</code></pre>

<pre><code>## Nonlinear regression model
##   model:  yeps ~ tmp(x, coef) 
##    data:  parent.frame() 
## coef1 coef2 
##     3     2 
##  residual sum-of-squares: 0.00124
## 
## Number of iterations to convergence: 2 
## Achieved convergence tolerance: 5.06e-09
</code></pre>

<pre><code class="r">
tmp1 &lt;- function(coef) {
    a &lt;- coef[1]
    b &lt;- coef[2]
    a + b * x
}
nls(yeps ~ tmp1(coef), start = list(coef = c(0.12345, 0.54321)))
</code></pre>

<pre><code>## Nonlinear regression model
##   model:  yeps ~ tmp1(coef) 
##    data:  parent.frame() 
## coef1 coef2 
##     3     2 
##  residual sum-of-squares: 0.00124
## 
## Number of iterations to convergence: 2 
## Achieved convergence tolerance: 5.06e-09
</code></pre>

<p>Some R functions to do nonlinear least squares:</p>

<pre><code class="r">## Example from R-help
y &lt;- c(5.5199668, 1.5234525, 3.3557, 6.7211704, 7.4237955, 1.9703127, 4.3939336, 
    -1.4380091, 3.265018, 3.5760906, 0.2947972, 1.0569417)
x &lt;- c(1, 0, 0, 4, 3, 5, 12, 10, 12, 100, 100, 100)
# Define target function as difference
f &lt;- function(b) b[1] * (exp((b[2] - x)/b[3]) * (1/b[3]))/(1 + exp((b[2] - x)/b[3]))^2 - 
    y
x0 &lt;- c(21.16322, 8.83669, 2.957765)
lsqnonlin(f, x0)  # ssq 50.50144 at c(36.133144, 2.572373, 1.079811)

# nls() will break down
nls(y ~ a * (exp((b - x)/c) * (1/c))/(1 + exp((b - x)/c))^2, start = list(a = 21.16322, 
    b = 8.83669, c = 2.957765), algorithm = &quot;plinear&quot;)
# Error: step factor 0.000488281 reduced below &#39;minFactor&#39; of 0.000976563
nls.lm(par = x0, fn = f)

</code></pre>

<pre><code class="r">load(&quot;ex2.rda&quot;)
load(&quot;ex1.rda&quot;)
load(&quot;ex1_a.rda&quot;)
mkinmodini &lt;- ex2
## Get the parametrization.
  inpartri &lt;- mkinmodini$inpartri
  outpartri &lt;- mkinmodini$outpartri
  ##

  ## mkinmodini is an object by mkinmod.full
  parms.ini &lt;- mkinmodini$parms.ini
  state.ini &lt;- mkinmodini$state.ini
  lower &lt;- mkinmodini$lower
  upper &lt;- mkinmodini$upper
  fixed_parms &lt;- mkinmodini$fixed_parms
  fixed_initials &lt;- mkinmodini$fixed_initials
  mod_vars &lt;- names(mkinmodini$diffs)
  observed &lt;-  mkin_wide_to_long(mkinmodini$residue,time=&#39;time&#39;)
  observed$err &lt;-c(as.matrix(mkinmodini$weightmat))
  ## Subset dataframe with mapped (modelled) variables
  observed &lt;- subset(observed, name %in% names(mkinmodini$map))
  ## Get names of observed variables
  ## NOTE HERE: the order may not be the same as the input mkinmod.full differential equations list. ## XXXXX TODO XXXX Reorder them maybe a good idea if the data is given from a data file while the mkinmod.full is defined not following the colnames order, although it is already taken care of in the cost(P) function to reorder the odeini using mod_vars
  obs_vars = unique(as.character(observed$name))


  ## Name the parameters if they are not named yet ## usually they are already names
  if(is.null(names(parms.ini))) names(parms.ini) &lt;- mkinmodini$parms

  ## Name the inital parameter values if they are not named yet
  if(is.null(names(state.ini))) names(state.ini) &lt;- mod_vars

  ## Parameters to be optimised
  parms.fixed &lt;- parms.ini[fixed_parms]
  optim_parms &lt;- setdiff(names(parms.ini), fixed_parms)
  parms.optim &lt;- parms.ini[optim_parms]


  ## # ### ### ### ### ###
  state.ini.fixed &lt;- state.ini[fixed_initials]
  optim_initials &lt;- setdiff(names(state.ini), fixed_initials)
  state.ini.optim &lt;- state.ini[optim_initials]
  state.ini.optim.boxnames &lt;- names(state.ini.optim)
  state.ini.fixed.boxnames &lt;- names(state.ini.fixed)
  if(length(state.ini.optim) &gt; 0) {
    names(state.ini.optim) &lt;- paste(&#39;M0&#39;,names(state.ini.optim),  sep=&quot;_&quot;)
  }
  if(length(state.ini.fixed) &gt; 0) {
    names(state.ini.fixed) &lt;- paste(&#39;M0&#39;,names(state.ini.fixed), sep=&quot;_&quot;)
  }

  eigen &lt;- FALSE
  oldparms &lt;- c(state.ini.optim,parms.optim)
  if (length(mkinmodini$map) == 1) {
    solution = &quot;analytical&quot;
  } else {
    if (is.matrix(mkinmodini$coefmat) &amp; eigen) solution = &quot;eigen&quot;
    else solution = &quot;deSolve&quot;
  }
  ## always define mkindiff function since most of the time we will use it.
  mkindiff &lt;- function(t, state, parms) {
    time &lt;- t
    diffs &lt;- vector()
    for (box in mod_vars)
    {
      diffname &lt;- paste(&quot;d&quot;, box, sep=&quot;_&quot;)
      diffs[diffname] &lt;- with(as.list(c(time,state, parms)),
                              eval(parse(text=mkinmodini$diffs[[box]])))
    }
    return(list(c(diffs)))
  }
#####################
ctr=kingui.control()
 #### Control parameters ####
  method &lt;- ctr$method
  odesolver &lt;- ctr$odesolver
  atol &lt;- ctr$atol
  rtol &lt;- ctr$rtol
  control &lt;- ctr$control
  marqctr &lt;- ctr$marqctr
  goMarq &lt;- ctr$goMarq
  submethod &lt;- ctr$submethod
  Hmethod1 &lt;- ctr$Hmethod1
  Hmethod2 &lt;- ctr$Hmethod2
####################
environment(kin_mod) &lt;- environment()
oldparms &lt;- c(state.ini.optim,parms.optim)
y &lt;- observed$value
kin_mod(P=oldparms)-y

y &lt;- observed$value
a &lt;- nls(y ~ kin_mod(P,pnames=names(oldparms)),start=list(P=oldparms),lower=lower,upper=upper,algorithm=&quot;port&quot;)
summary(a)
f &lt;- function(P){
    res &lt;- observed$value-kin_mod(P)
    id &lt;- which(is.na(res))
    return(res[-id])
  }
b &lt;- nls.lm(par=oldparms,lower=lower,upper=upper,fn=f)
b1 &lt;- nls.lm(par=oldparms,lower=lower,upper=upper,fn=f,control=nls.lm.control(maxiter=100))
compare_multi_kinmod(mkinmodini,t(coef(b)))
pnames &lt;- names(oldparms)
obj1 &lt;- function(P,lower,upper,...)
  {
    if(is.null(names(P))) names(P) &lt;- pnames
    if((any(P&lt;lower)) || (any(P&gt;upper)) return(1e100) else return(0.5*sum((kin_mod(P,...)-y)^2,na.rm=TRUE))
  }
## utilities
gradfun_ls &lt;- function(modelfun,par,obs,...)
{
  if(is.null(names(par))) names(par) &lt;- pnames
  np &lt;- length(par)
  resfun &lt;- function(par,obs, ...){
    modelfun(par,...)-obs
  }
  res &lt;- resfun(par,obs=obs)
  Jmat &lt;- jacobian(modelfun,x=par)
  ## when there are NA&#39;s, not included in the Jaobian!!!
  id &lt;- which(is.na(res))
  g &lt;- t(Jmat[-id,])%*%res[-id]
  return(g)
}
gr1 &lt;- function(P,...)
  {
    g&lt;-gradfun_ls(modelfun=kin_mod,par=P,obs=observed$value)
    g
  }
c &lt;- trust.optim(x=oldparms,fn=obj1,gr=gr1,method=&quot;SR1&quot;)
c.1 &lt;- trust.optim(x=oldparms,fn=obj1,gr=gr1,method=&quot;BFGS&quot;)
## Next using trust.
obj &lt;- function(par,Q=FALSE,...)
  {
    return(objfun_ls(modelfun=kin_mod,par,obs=observed$value,Q=Q,pnames=pnames...))

  }
d &lt;- trust_ls(objfun=obj,parinit=oldparms,rinit=1,rmax=100)
###### Case 1: nls.lm better than nls
###### Case 2: trust.optim better than nls.lm
###### Case 3: STIR is the one for all

</code></pre>

<hr/>

<h1>Stackoverflow Question</h1>

<p>My original question was &ldquo;Implementation of trust-region-reflective optimization algorithm in R&rdquo;. However, on the way of producing a reproducible example(thanks @Ben for his advice), I realize that my problem is that in Matlab, one function <code>lsqnonlin</code> is good(meaning no need to choose a good starting value, fast) enough for most cases I have, while in R, there is not such a one-for-all function. Different optmization algorithm works well in different cases. Different algorithms reach different solutions. The reason behind this may not be that the optimization algorithms in R is inferior to the trust-region-reflective algorithm in Matlab, it could also be related to how R handles Automatic Differentiation. This problem comes actually from interrupted work two years ago. At that time, Prof. John C Nash, one of the authors of the package <strong>optimx</strong> has suggested that there has been quite a lot of work for Matlab for Automatic Differentiation, which might be the reason that the Matlab lsqnonlin performs better than the optimization functions/algorithms in R. I am not able to figure it out with my knowledge. </p>

<p>The example below shows some problems I have encountered(More reproducible examples are coming). To run the examples, first run <code>install_github(&quot;KineticEval&quot;,&quot;zhenglei-gao&quot;)</code>. You need to install package <strong>mkin</strong> and its dependencies and may also need to install a bunch of other packages for different optimization algorithms.</p>

<p>Basically I am trying to solve nonlinear least-squares curve fitting problems as described in the Matlab function <code>lsqnonlin</code> &#39;s documentation (<a href="http://www.mathworks.de/de/help/optim/ug/lsqnonlin.html">http://www.mathworks.de/de/help/optim/ug/lsqnonlin.html</a>). The curves in my case are modeled by a set of differential equations. I will explain a bit more with the examples. Optimization algorithms I have tried including:</p>

<ul>
<li>Marq from <code>nls.lm</code>, the Levenburg-Marquardt</li>
<li>Port from <code>nlm.inb</code></li>
<li>L-BGFS-B from <code>optim</code></li>
<li>spg from <code>optimx</code></li>
<li><code>solnp</code> of package <strong>Rsolnp</strong></li>
</ul>

<p>I have also tried a few others but here are the ones I will often use. </p>

<h2>Example 1: A simple case</h2>

<p>I will give the R codes first and explain later.</p>

<pre><code class="r">ex1 &lt;- mkinmod.full(Parent = list(type = &quot;SFO&quot;, to = &quot;Metab&quot;, sink = TRUE, k = list(ini = 0.1, 
    fixed = 0, lower = 0, upper = Inf), M0 = list(ini = 195, fixed = 0, lower = 0, 
    upper = Inf), FF = list(ini = c(0.1), fixed = c(0), lower = c(0), upper = c(1)), 
    time = c(0, 2.8, 6.2, 12, 29.2, 66.8, 99.8, 127.5, 154.4, 229.9, 272.3, 
        288.1, 322.9), residue = c(157.3, 206.3, 181.4, 223, 163.2, 144.7, 85, 
        76.5, 76.4, 51.5, 45.5, 47.3, 42.7), weight = c(1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1)), Metab = list(type = &quot;SFO&quot;, k = list(ini = 0.1, fixed = 0, 
    lower = 0, upper = Inf), M0 = list(ini = 0, fixed = 1, lower = 0, upper = Inf), 
    residue = c(0, 0, 0, 1.6, 4, 12.3, 13.5, 12.7, 11.4, 11.6, 10.9, 9.5, 7.6), 
    weight = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)))
ex1$diffs
Fit &lt;- NULL
alglist &lt;- c(&quot;L-BFGS-B&quot;, &quot;Marq&quot;, &quot;Port&quot;, &quot;spg&quot;, &quot;solnp&quot;)
for (i in 1:5) {
    Fit[[i]] &lt;- mkinfit.full(ex1, plot = TRUE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
names(Fit) &lt;- alglist
(lapply(Fit, function(x) x$par))
kinplot(Fit[[2]])
unlist(lapply(Fit, function(x) x$ssr))
</code></pre>

<p>The output from the last line is:</p>

<pre><code>L-BFGS-B     Marq     Port      spg    solnp 
5735.744 4714.500 5780.446 5728.361 4714.499 
</code></pre>

<p>Except for &ldquo;Marq&rdquo; and &ldquo;solnp&rdquo;, the other algorithms did not reach the optimum.Besides, &#39;spg&#39; method (also other methods like &#39;bobyqa&#39;) need too many function evaluations for such a simple case . Moreover, if I change the starting value and make <code>k_Parent=0.0058</code> (the optimum value for that parameter) instead of the random choosen <code>0.1</code>,  &ldquo;Marq&rdquo; cannot find the optimum any more! (Code provided below). I have also had datasets where &ldquo;solnp&rdquo; does not find the optimum. However, if I use <code>lsqnonlin</code> in Matlab, I haven&#39;t encountered any difficulties for such simple cases. </p>

<pre><code class="r">ex1_a &lt;- mkinmod.full(Parent = list(type = &quot;SFO&quot;, to = &quot;Metab&quot;, sink = TRUE, 
    k = list(ini = 0.0058, fixed = 0, lower = 0, upper = Inf), M0 = list(ini = 195, 
        fixed = 0, lower = 0, upper = Inf), FF = list(ini = c(0.1), fixed = c(0), 
        lower = c(0), upper = c(1)), time = c(0, 2.8, 6.2, 12, 29.2, 66.8, 99.8, 
        127.5, 154.4, 229.9, 272.3, 288.1, 322.9), residue = c(157.3, 206.3, 
        181.4, 223, 163.2, 144.7, 85, 76.5, 76.4, 51.5, 45.5, 47.3, 42.7), weight = c(1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)), Metab = list(type = &quot;SFO&quot;, k = list(ini = 0.1, 
    fixed = 0, lower = 0, upper = Inf), M0 = list(ini = 0, fixed = 1, lower = 0, 
    upper = Inf), residue = c(0, 0, 0, 1.6, 4, 12.3, 13.5, 12.7, 11.4, 11.6, 
    10.9, 9.5, 7.6), weight = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)))

Fit_a &lt;- NULL
alglist &lt;- c(&quot;L-BFGS-B&quot;, &quot;Marq&quot;, &quot;Port&quot;, &quot;spg&quot;, &quot;solnp&quot;)
for (i in 1:5) {
    Fit_a[[i]] &lt;- mkinfit.full(ex1_a, plot = TRUE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
names(Fit_a) &lt;- alglist
lapply(Fit_a, function(x) x$par)
unlist(lapply(Fit_a, function(x) x$ssr))
</code></pre>

<p>Now the output from last line is:</p>

<pre><code>L-BFGS-B     Marq     Port      spg    solnp 
5653.132 4866.961 5653.070 5635.372 4714.499 
</code></pre>

<p>I will explain what I am optimising here. If you have run the above script and see the curves, we use a two-compartment model with first order reactions to describe the curves. The differential equations to express the model are:</p>

<pre><code class="r">ex1$diffs
</code></pre>

<pre><code>                                                             Parent 
                                    &quot;d_Parent = - k_Parent * Parent&quot; 
                                                               Metab 
&quot;d_Metab = - k_Metab * Metab + k_Parent * f_Parent_to_Metab * Parent&quot; 
</code></pre>

<p>For this simple case, from the differential equations we can derive the equations to describe the two curves. The to be optimized parameters are $M_0,k_p, k_m, c=\mbox{FF_parent_to_Met} $ with the constraints \( M_0>0,k_p>0, k_m>0, 1> c >0 \).</p>

<p>\[ 
\begin{split}
            y_{1j}&= M_0e^{-k_pt_i}+\epsilon_{1j}\\
            y_{2j} &= cM_0k_p\frac{e^{-k_mt_i}-e^{-k_pt_i}}{k_p-k_m}+\epsilon_{2j}
            \end{split}
 \]</p>

<p>Therefore we can fit the curve without solving differential equations. </p>

<pre><code class="r">BCS1.l &lt;- mkin_wide_to_long(BCS1)
BCS1.l &lt;- na.omit(BCS1.l)
indi &lt;- c(rep(1, sum(BCS1.l$name == &quot;Parent&quot;)), rep(0, sum(BCS1.l$name == &quot;Metab&quot;)))
sysequ.indi &lt;- function(t, indi, M0, kp, km, C) {
    y &lt;- indi * M0 * exp(-kp * t) + (1 - indi) * C * M0 * kp/(kp - km) * (exp(-km * 
        t) - exp(-kp * t))
    y
}
M00 &lt;- 100
kp0 &lt;- 0.1
km0 &lt;- 0.01
C0 &lt;- 0.1
library(nlme)
result1 &lt;- gnls(value ~ sysequ.indi(time, indi, M0, kp, km, C), data = BCS1.l, 
    start = list(M0 = M00, kp = kp0, km = km0, C = C0), control = gnlsControl())
# result3 &lt;- gnls(value ~
# sysequ.indi(time,indi,M0,kp,km,C),data=BCS1.l,start=list(M0=M00,kp=kp0,km=km0,C=C0),weights
# = varIdent(form=~1|name)) Coefficients: M0 kp km C 1.946170e+02
# 5.800074e-03 8.404269e-03 2.208788e-01
</code></pre>

<p>Doing this way, the elapsed time is almost 0, and the optimum is reached. However, we do not always have this simple case. The model can be complex and solving the differential equations is needed. See example 2</p>

<h2>Example 2, a complex model</h2>

<p>I worked on this dataset a long time ago and haven&#39;t got time to finish running the following script myself. (You might need hours to finish running.) </p>

<pre><code class="r">data(BCS2)
ex2 &lt;- mkinmod.full(Parent = list(type = &quot;SFO&quot;, to = c(&quot;Met1&quot;, &quot;Met2&quot;, &quot;Met4&quot;, 
    &quot;Met5&quot;), k = list(ini = 0.1, fixed = 0, lower = 0, upper = Inf), M0 = list(ini = 100, 
    fixed = 0, lower = 0, upper = Inf), FF = list(ini = c(0.1, 0.1, 0.1, 0.1), 
    fixed = c(0, 0, 0, 0), lower = c(0, 0, 0, 0), upper = c(1, 1, 1, 1))), Met1 = list(type = &quot;SFO&quot;, 
    to = c(&quot;Met3&quot;, &quot;Met4&quot;)), Met2 = list(type = &quot;SFO&quot;, to = c(&quot;Met3&quot;)), Met3 = list(type = &quot;SFO&quot;), 
    Met4 = list(type = &quot;SFO&quot;, to = c(&quot;Met5&quot;)), Met5 = list(type = &quot;SFO&quot;), data = BCS2)
ex2$diffs
Fit2 &lt;- NULL
alglist &lt;- c(&quot;L-BFGS-B&quot;, &quot;Marq&quot;, &quot;Port&quot;, &quot;spg&quot;, &quot;solnp&quot;)
for (i in 1:5) {
    Fit2[[i]] &lt;- mkinfit.full(ex2, plot = TRUE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
kinplot(Fit2[[5]])
names(Fit) &lt;- alglist
(lapply(Fit, function(x) x$par))
unlist(lapply(Fit, function(x) x$ssr))

</code></pre>

<p>This is an example where you will see warning messages like:</p>

<pre><code>DLSODA-  At T (=R1) and step size H (=R2), the    
  corrector convergence failed repeatedly     
  or with ABS(H) = HMIN   
In above message, R = 
[1] 0.000000e+00 2.289412e-09
</code></pre>

<h2>Issues in R</h2>

<ul>
<li>Different algorithms reach different solutions. </li>
<li>Missing global minimum</li>
<li>Lower Efficiency</li>
</ul>

<p>I have to adimit that this problem comes actually from interrupted work two years ago. At that time, Prof. John C Nash, one of the authors of the package <code>optimx</code> has suggested that there has been quite a lot of work for Matlab for Automatic Differentiation, which might be the reason that the Matlab <code>lsqnonlin</code> performs better than the optimization functions/algorithms in R. </p>

<p>Thanks @Ben Bolke at Stackoverflow for his advice of giving a <strong>concrete, reproducible</strong> example of a problem where R&#39;s optimizers do significantly worse than <code>lsqnonlin</code> and reframe my original question of &ldquo;can I implement algorithm xxyy in R?&rdquo;. This makes me sit down and digging out emails and examples and have a review of my previous work. </p>

<pre><code class="r">summary(cars)
</code></pre>

<pre><code>##      speed           dist    
##  Min.   : 4.0   Min.   :  2  
##  1st Qu.:12.0   1st Qu.: 26  
##  Median :15.0   Median : 36  
##  Mean   :15.4   Mean   : 43  
##  3rd Qu.:19.0   3rd Qu.: 56  
##  Max.   :25.0   Max.   :120
</code></pre>

<p>You can also embed plots, for example:</p>

<pre><code class="r">###
</code></pre>

<h2>Sources</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/13069627/library-for-trust-region-reflective-algorithms-in-c">http://stackoverflow.com/questions/13069627/library-for-trust-region-reflective-algorithms-in-c</a></li>
<li>Ipopt</li>
<li><a href="http://www.mathworks.de/de/help/optim/ug/constrained-nonlinear-optimization-algorithms.html">http://www.mathworks.de/de/help/optim/ug/constrained-nonlinear-optimization-algorithms.html</a></li>
<li><a href="http://stackoverflow.com/questions/5527145/convert-matlab-code-to-r">http://stackoverflow.com/questions/5527145/convert-matlab-code-to-r</a></li>
</ul>

</body>

</html>

