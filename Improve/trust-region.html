<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Trust Region Reflective?</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>


<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<h1>Trust Region Reflective?</h1>

<p>Other&#39;s implementation</p>

<ul>
<li><a href="https://bitbucket.org/carandraug/octave/src/13d1e9bfa362/scripts/optimization/lsqnonneg.m?at=default">https://bitbucket.org/carandraug/octave/src/13d1e9bfa362/scripts/optimization/lsqnonneg.m?at=default</a></li>
</ul>

<hr/>

<h1>Stackoverflow Question</h1>

<p>My original question was &ldquo;Implementation of trust-region-reflective optimization algorithm in R&rdquo;. However, on the way of producing a reproducible example(thanks @Ben for his advice), I realize that my problem is that in Matlab, one function <code>lsqnonlin</code> is good(meaning no need to choose a good starting value, fast) enough for most cases I have, while in R, there is not such a one-for-all function. Different optmization algorithm works well in different cases. Different algorithms reach different solutions. The reason behind this may not be that the optimization algorithms in R is inferior to the trust-region-reflective algorithm in Matlab, it could also be related to how R handles Automatic Differentiation. This problem comes actually from interrupted work two years ago. At that time, Prof. John C Nash, one of the authors of the package <strong>optimx</strong> has suggested that there has been quite a lot of work for Matlab for Automatic Differentiation, which might be the reason that the Matlab lsqnonlin performs better than the optimization functions/algorithms in R. I am not able to figure it out with my knowledge. </p>

<p>The example below shows some problems I have encountered(More reproducible examples are coming). To run the examples, first run <code>install_github(&quot;KineticEval&quot;,&quot;zhenglei-gao&quot;)</code>. You need to install package <strong>mkin</strong> and its dependencies and may also need to install a bunch of other packages for different optimization algorithms.</p>

<p>Basically I am trying to solve nonlinear least-squares curve fitting problems as described in the Matlab function <code>lsqnonlin</code> &#39;s documentation (<a href="http://www.mathworks.de/de/help/optim/ug/lsqnonlin.html">http://www.mathworks.de/de/help/optim/ug/lsqnonlin.html</a>). The curves in my case are modeled by a set of differential equations. I will explain a bit more with the examples. Optimization algorithms I have tried including:</p>

<ul>
<li>Marq from <code>nls.lm</code>, the Levenburg-Marquardt</li>
<li>Port from <code>nlm.inb</code></li>
<li>L-BGFS-B from <code>optim</code></li>
<li>spg from <code>optimx</code></li>
<li><code>solnp</code> of package <strong>Rsolnp</strong></li>
</ul>

<p>I have also tried a few others but here are the ones I will often use. </p>

<h2>Example 1: A simple case</h2>

<p>I will give the R codes first and explain later.</p>

<pre><code class="r">ex1 &lt;- mkinmod.full(Parent = list(type = &quot;SFO&quot;, to = &quot;Metab&quot;, sink = TRUE, k = list(ini = 0.1, 
    fixed = 0, lower = 0, upper = Inf), M0 = list(ini = 195, fixed = 0, lower = 0, 
    upper = Inf), FF = list(ini = c(0.1), fixed = c(0), lower = c(0), upper = c(1)), 
    time = c(0, 2.8, 6.2, 12, 29.2, 66.8, 99.8, 127.5, 154.4, 229.9, 272.3, 
        288.1, 322.9), residue = c(157.3, 206.3, 181.4, 223, 163.2, 144.7, 85, 
        76.5, 76.4, 51.5, 45.5, 47.3, 42.7), weight = c(1, 1, 1, 1, 1, 1, 1, 
        1, 1, 1, 1, 1, 1)), Metab = list(type = &quot;SFO&quot;, k = list(ini = 0.1, fixed = 0, 
    lower = 0, upper = Inf), M0 = list(ini = 0, fixed = 1, lower = 0, upper = Inf), 
    residue = c(0, 0, 0, 1.6, 4, 12.3, 13.5, 12.7, 11.4, 11.6, 10.9, 9.5, 7.6), 
    weight = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)))
ex1$diffs
Fit &lt;- NULL
alglist &lt;- c(&quot;L-BFGS-B&quot;, &quot;Marq&quot;, &quot;Port&quot;, &quot;spg&quot;, &quot;solnp&quot;)
for (i in 1:5) {
    Fit[[i]] &lt;- mkinfit.full(ex1, plot = TRUE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
names(Fit) &lt;- alglist
(lapply(Fit, function(x) x$par))
kinplot(Fit[[2]])
unlist(lapply(Fit, function(x) x$ssr))
</code></pre>

<p>The output from the last line is:</p>

<pre><code>L-BFGS-B     Marq     Port      spg    solnp 
5735.744 4714.500 5780.446 5728.361 4714.499 
</code></pre>

<p>Except for &ldquo;Marq&rdquo; and &ldquo;solnp&rdquo;, the other algorithms did not reach the optimum.Besides, &#39;spg&#39; method (also other methods like &#39;bobyqa&#39;) need too many function evaluations for such a simple case . Moreover, if I change the starting value and make <code>k_Parent=0.0058</code> (the optimum value for that parameter) instead of the random choosen <code>0.1</code>,  &ldquo;Marq&rdquo; cannot find the optimum any more! (Code provided below). I have also had datasets where &ldquo;solnp&rdquo; does not find the optimum. However, if I use <code>lsqnonlin</code> in Matlab, I haven&#39;t encountered any difficulties for such simple cases. </p>

<pre><code class="r">ex1_a &lt;- mkinmod.full(Parent = list(type = &quot;SFO&quot;, to = &quot;Metab&quot;, sink = TRUE, 
    k = list(ini = 0.0058, fixed = 0, lower = 0, upper = Inf), M0 = list(ini = 195, 
        fixed = 0, lower = 0, upper = Inf), FF = list(ini = c(0.1), fixed = c(0), 
        lower = c(0), upper = c(1)), time = c(0, 2.8, 6.2, 12, 29.2, 66.8, 99.8, 
        127.5, 154.4, 229.9, 272.3, 288.1, 322.9), residue = c(157.3, 206.3, 
        181.4, 223, 163.2, 144.7, 85, 76.5, 76.4, 51.5, 45.5, 47.3, 42.7), weight = c(1, 
        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)), Metab = list(type = &quot;SFO&quot;, k = list(ini = 0.1, 
    fixed = 0, lower = 0, upper = Inf), M0 = list(ini = 0, fixed = 1, lower = 0, 
    upper = Inf), residue = c(0, 0, 0, 1.6, 4, 12.3, 13.5, 12.7, 11.4, 11.6, 
    10.9, 9.5, 7.6), weight = c(1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1)))

Fit_a &lt;- NULL
alglist &lt;- c(&quot;L-BFGS-B&quot;, &quot;Marq&quot;, &quot;Port&quot;, &quot;spg&quot;, &quot;solnp&quot;)
for (i in 1:5) {
    Fit_a[[i]] &lt;- mkinfit.full(ex1_a, plot = TRUE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
names(Fit_a) &lt;- alglist
lapply(Fit_a, function(x) x$par)
unlist(lapply(Fit_a, function(x) x$ssr))
</code></pre>

<p>Now the output from last line is:</p>

<pre><code>L-BFGS-B     Marq     Port      spg    solnp 
5653.132 4866.961 5653.070 5635.372 4714.499 
</code></pre>

<p>I will explain what I am optimising here. If you have run the above script and see the curves, we use a two-compartment model with first order reactions to describe the curves. The differential equations to express the model are:</p>

<pre><code class="r">ex1$diffs
</code></pre>

<pre><code>                                                             Parent 
                                    &quot;d_Parent = - k_Parent * Parent&quot; 
                                                               Metab 
&quot;d_Metab = - k_Metab * Metab + k_Parent * f_Parent_to_Metab * Parent&quot; 
</code></pre>

<p>For this simple case, from the differential equations we can derive the equations to describe the two curves. The to be optimized parameters are $M_0,k_p, k_m, c=\mbox{FF_parent_to_Met} $ with the constraints \( M_0>0,k_p>0, k_m>0, 1> c >0 \).</p>

<p>\[ 
\begin{split}
            y_{1j}&= M_0e^{-k_pt_i}+\epsilon_{1j}\\
            y_{2j} &= cM_0k_p\frac{e^{-k_mt_i}-e^{-k_pt_i}}{k_p-k_m}+\epsilon_{2j}
            \end{split}
 \]</p>

<p>Therefore we can fit the curve without solving differential equations. </p>

<pre><code class="r">BCS1.l &lt;- mkin_wide_to_long(BCS1)
BCS1.l &lt;- na.omit(BCS1.l)
indi &lt;- c(rep(1, sum(BCS1.l$name == &quot;Parent&quot;)), rep(0, sum(BCS1.l$name == &quot;Metab&quot;)))
sysequ.indi &lt;- function(t, indi, M0, kp, km, C) {
    y &lt;- indi * M0 * exp(-kp * t) + (1 - indi) * C * M0 * kp/(kp - km) * (exp(-km * 
        t) - exp(-kp * t))
    y
}
M00 &lt;- 100
kp0 &lt;- 0.1
km0 &lt;- 0.01
C0 &lt;- 0.1
library(nlme)
result1 &lt;- gnls(value ~ sysequ.indi(time, indi, M0, kp, km, C), data = BCS1.l, 
    start = list(M0 = M00, kp = kp0, km = km0, C = C0), control = gnlsControl())
# result3 &lt;- gnls(value ~
# sysequ.indi(time,indi,M0,kp,km,C),data=BCS1.l,start=list(M0=M00,kp=kp0,km=km0,C=C0),weights
# = varIdent(form=~1|name)) Coefficients: M0 kp km C 1.946170e+02
# 5.800074e-03 8.404269e-03 2.208788e-01
</code></pre>

<p>Doing this way, the elapsed time is almost 0, and the optimum is reached. However, we do not always have this simple case. The model can be complex and solving the differential equations is needed. See example 2</p>

<h2>Example 2, a complex model</h2>

<p>I worked on this dataset a long time ago and haven&#39;t got time to finish running the following script myself. (You might need hours to finish running.) </p>

<pre><code class="r">data(BCS2)
ex2 &lt;- mkinmod.full(Parent = list(type = &quot;SFO&quot;, to = c(&quot;Met1&quot;, &quot;Met2&quot;, &quot;Met4&quot;, 
    &quot;Met5&quot;), k = list(ini = 0.1, fixed = 0, lower = 0, upper = Inf), M0 = list(ini = 100, 
    fixed = 0, lower = 0, upper = Inf), FF = list(ini = c(0.1, 0.1, 0.1, 0.1), 
    fixed = c(0, 0, 0, 0), lower = c(0, 0, 0, 0), upper = c(1, 1, 1, 1))), Met1 = list(type = &quot;SFO&quot;, 
    to = c(&quot;Met3&quot;, &quot;Met4&quot;)), Met2 = list(type = &quot;SFO&quot;, to = c(&quot;Met3&quot;)), Met3 = list(type = &quot;SFO&quot;), 
    Met4 = list(type = &quot;SFO&quot;, to = c(&quot;Met5&quot;)), Met5 = list(type = &quot;SFO&quot;), data = BCS2)
ex2$diffs
Fit2 &lt;- NULL
alglist &lt;- c(&quot;L-BFGS-B&quot;, &quot;Marq&quot;, &quot;Port&quot;, &quot;spg&quot;, &quot;solnp&quot;)
for (i in 1:5) {
    Fit2[[i]] &lt;- mkinfit.full(ex2, plot = TRUE, quiet = TRUE, ctr = kingui.control(method = alglist[i], 
        submethod = &quot;Port&quot;, maxIter = 100, tolerance = 1e-06, odesolver = &quot;lsoda&quot;))
}
kinplot(Fit2[[5]])
names(Fit) &lt;- alglist
(lapply(Fit, function(x) x$par))
unlist(lapply(Fit, function(x) x$ssr))

</code></pre>

<p>This is an example where you will see warning messages like:</p>

<pre><code>DLSODA-  At T (=R1) and step size H (=R2), the    
  corrector convergence failed repeatedly     
  or with ABS(H) = HMIN   
In above message, R = 
[1] 0.000000e+00 2.289412e-09
</code></pre>

<h2>Issues in R</h2>

<ul>
<li>Different algorithms reach different solutions. </li>
<li>Missing global minimum</li>
<li>Lower Efficiency</li>
</ul>

<p>I have to adimit that this problem comes actually from interrupted work two years ago. At that time, Prof. John C Nash, one of the authors of the package <code>optimx</code> has suggested that there has been quite a lot of work for Matlab for Automatic Differentiation, which might be the reason that the Matlab <code>lsqnonlin</code> performs better than the optimization functions/algorithms in R. </p>

<p>Thanks @Ben Bolke at Stackoverflow for his advice of giving a <strong>concrete, reproducible</strong> example of a problem where R&#39;s optimizers do significantly worse than <code>lsqnonlin</code> and reframe my original question of &ldquo;can I implement algorithm xxyy in R?&rdquo;. This makes me sit down and digging out emails and examples and have a review of my previous work. </p>

<pre><code class="r">summary(cars)
</code></pre>

<pre><code>##      speed           dist    
##  Min.   : 4.0   Min.   :  2  
##  1st Qu.:12.0   1st Qu.: 26  
##  Median :15.0   Median : 36  
##  Mean   :15.4   Mean   : 43  
##  3rd Qu.:19.0   3rd Qu.: 56  
##  Max.   :25.0   Max.   :120
</code></pre>

<p>You can also embed plots, for example:</p>

<pre><code class="r">###
</code></pre>

<h2>Sources</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/13069627/library-for-trust-region-reflective-algorithms-in-c">http://stackoverflow.com/questions/13069627/library-for-trust-region-reflective-algorithms-in-c</a></li>
<li>Ipopt</li>
<li><a href="http://www.mathworks.de/de/help/optim/ug/constrained-nonlinear-optimization-algorithms.html">http://www.mathworks.de/de/help/optim/ug/constrained-nonlinear-optimization-algorithms.html</a></li>
<li><a href="http://stackoverflow.com/questions/5527145/convert-matlab-code-to-r">http://stackoverflow.com/questions/5527145/convert-matlab-code-to-r</a></li>
</ul>

</body>

</html>

